<script lang="ts">
  import { onMount, createEventDispatcher } from "svelte";
  import { TableData, EditingStateByID } from "../types/datatable";
  import {
    GetTableDataByID,
    UpdateCellValueByID,
    UpdateColumnNameByID,
    GetText,
  } from "../../wailsjs/go/main/App";
  import ContextMenu from "./ContextMenu.svelte";
  import type { ContextMenuConfig } from "../types/contextMenu";

  // 組件屬性
  export let tableID: number;
  export let tableKey: number = 0; // 用於強制重新載入的 key

  // 創建事件分發器
  const dispatch = createEventDispatcher();

  // i18n 翻譯輔助函數
  async function t(key: string, vars?: Record<string, any>): Promise<string> {
    try {
      let text = await GetText(key);
      if (vars) {
        Object.entries(vars).forEach(([key, value]) => {
          text = text.replace(`{${key}}`, value);
        });
      }
      return text;
    } catch (error) {
      console.warn(`Translation missing for key: ${key}`);
      return key;
    }
  }
  // 翻譯文字快取
  let texts: Record<string, string> = {};

  // 載入翻譯文字
  async function loadTexts() {
    const keys = [
      "ui.table.loading",
      "ui.table.no_data",
      "ui.table.selected_content",
      "ui.table.selected_row",
      "ui.table.selected_column",
      "ui.table.cell_position",
      "ui.table.update_failed",
      "ui.context_menu.insert_row_above",
      "ui.context_menu.insert_row_below",
      "ui.context_menu.duplicate_row",
      "ui.context_menu.delete_row",
      "ui.context_menu.insert_column_left",
      "ui.context_menu.insert_column_right",
      "ui.context_menu.rename_column",
      "ui.context_menu.duplicate_column",
      "ui.context_menu.delete_column",
      "ui.context_menu.copy",
      "ui.context_menu.paste",
      "ui.context_menu.clear",
    ];

    for (const key of keys) {
      try {
        texts[key] = await GetText(key);
      } catch (error) {
        console.warn(`Failed to load translation for ${key}`);
      }
    }
  }
  // 狀態變數
  let tableData: TableData | null = null;
  let loading = true;
  let error = "";
  let lastTableID = -1;
  let lastTableKey = -1;

  // 編輯狀態
  let editingState: EditingStateByID = {
    tableID: -1,
    rowIndex: -1,
    colIndex: -1,
    colName: "",
    value: "",
    isEditing: false,
  };
  // 選中狀態
  let selectedRow = -1;
  let selectedCol = -1;
  let selectedCellContent = "";

  // 選擇模式：'cell' | 'row' | 'column'
  let selectionMode = "cell";
  let selectedRowRange = new Set(); // 選中的行範圍
  let selectedColRange = new Set(); // 選中的列範圍

  // 右鍵菜單狀態
  let contextMenuVisible = false;
  let contextMenuX = 0;
  let contextMenuY = 0;
  let contextMenuType = ""; // 'row' | 'column' | 'cell'
  let contextMenuContext = {}; // 上下文信息
  // 右鍵菜單配置
  let contextMenuConfig: ContextMenuConfig = {
    row: [
      { id: "insertRowAbove", label: "", icon: "⬆️" },
      { id: "insertRowBelow", label: "", icon: "⬇️" },
      { id: "separator1", type: "separator" },
      { id: "duplicateRow", label: "", icon: "📋" },
      { id: "separator2", type: "separator" },
      { id: "deleteRow", label: "", icon: "🗑️", danger: true },
    ],
    column: [
      { id: "insertColumnLeft", label: "", icon: "⬅️" },
      { id: "insertColumnRight", label: "", icon: "➡️" },
      { id: "separator1", type: "separator" },
      { id: "renameColumn", label: "", icon: "✏️" },
      { id: "duplicateColumn", label: "", icon: "📋" },
      { id: "separator2", type: "separator" },
      { id: "deleteColumn", label: "", icon: "🗑️", danger: true },
    ],
    cell: [
      { id: "copy", label: "", icon: "📋" },
      { id: "paste", label: "", icon: "📄", disabled: true },
      { id: "separator1", type: "separator" },
      { id: "clear", label: "", icon: "🧹" },
      { id: "separator2", type: "separator" },
      { id: "insertRowAbove", label: "", icon: "⬆️" },
      { id: "insertRowBelow", label: "", icon: "⬇️" },
      { id: "insertColumnLeft", label: "", icon: "⬅️" },
      { id: "insertColumnRight", label: "", icon: "➡️" },
    ],
  };

  // 更新菜單配置的翻譯文字
  function updateMenuLabels() {
    // Row menu
    contextMenuConfig.row[0].label =
      texts["ui.context_menu.insert_row_above"] || "在上方插入列";
    contextMenuConfig.row[1].label =
      texts["ui.context_menu.insert_row_below"] || "在下方插入列";
    contextMenuConfig.row[3].label =
      texts["ui.context_menu.duplicate_row"] || "複製列";
    contextMenuConfig.row[5].label =
      texts["ui.context_menu.delete_row"] || "刪除列";

    // Column menu
    contextMenuConfig.column[0].label =
      texts["ui.context_menu.insert_column_left"] || "在左邊插入變項";
    contextMenuConfig.column[1].label =
      texts["ui.context_menu.insert_column_right"] || "在右邊插入變項";
    contextMenuConfig.column[3].label =
      texts["ui.context_menu.rename_column"] || "重新命名變項";
    contextMenuConfig.column[4].label =
      texts["ui.context_menu.duplicate_column"] || "複製變項";
    contextMenuConfig.column[6].label =
      texts["ui.context_menu.delete_column"] || "刪除變項";

    // Cell menu
    contextMenuConfig.cell[0].label = texts["ui.context_menu.copy"] || "複製";
    contextMenuConfig.cell[1].label = texts["ui.context_menu.paste"] || "貼上";
    contextMenuConfig.cell[3].label =
      texts["ui.context_menu.clear"] || "清除內容";
    contextMenuConfig.cell[5].label =
      texts["ui.context_menu.insert_row_above"] || "在上方插入列";
    contextMenuConfig.cell[6].label =
      texts["ui.context_menu.insert_row_below"] || "在下方插入列";
    contextMenuConfig.cell[7].label =
      texts["ui.context_menu.insert_column_left"] || "在左邊插入變項";
    contextMenuConfig.cell[8].label =
      texts["ui.context_menu.insert_column_right"] || "在右邊插入變項";
  }

  // 防止雙擊時觸發點擊的標記
  let doubleClickInProgress = false;
  // 編輯輸入元素引用
  let editInput: HTMLInputElement; // 當進入編輯模式時，設置焦點
  $: if (editingState.isEditing && editInput) {
    setTimeout(() => {
      editInput.focus(); // 僅聚焦，不選取文字
      // editInput.select(); // 暫時移除此行
    }, 0);
  } // 響應式更新選中內容顯示
  $: if (tableData && !editingState.isEditing) {
    updateSelectedCellContent();
  }

  // 當選擇狀態變化時即時更新選中內容顯示
  $: if (tableData && (selectedRow >= 0 || selectedCol >= 0 || selectionMode)) {
    if (!editingState.isEditing) {
      updateSelectedCellContent();
    }
  }
  // 更新選中內容顯示的函數
  function updateSelectedCellContent() {
    if (!tableData) return;

    if (selectionMode === "row" && selectedRow >= 0) {
      selectedCellContent = (
        texts["ui.table.selected_row"] || "第 {row} 列"
      ).replace("{row}", (selectedRow + 1).toString());
    } else if (selectionMode === "column" && selectedCol >= 0) {
      selectedCellContent = (
        texts["ui.table.selected_column"] || "{column} 變項"
      ).replace("{column}", indexToLetters(selectedCol));
    } else if (
      selectionMode === "cell" &&
      selectedRow >= 0 &&
      selectedCol >= 0
    ) {
      const column = tableData.columns[selectedCol];
      if (column) {
        const cellValue = tableData.rows[selectedRow]?.cells[column.name];
        const displayValue = formatCellValue(cellValue);
        const position = (texts["ui.table.cell_position"] || "{column}{row}")
          .replace("{column}", indexToLetters(selectedCol))
          .replace("{row}", (selectedRow + 1).toString());
        selectedCellContent = `${position}: ${displayValue}`;
      }
    } else {
      selectedCellContent = "";
    }
  }
  onMount(async () => {
    lastTableID = tableID;
    lastTableKey = tableKey;

    // 載入翻譯文字
    await loadTexts();
    updateMenuLabels();

    await loadTableData();

    // 添加文檔點擊事件監聽器
    document.addEventListener("click", handleDocumentClick);

    return () => {
      // 清理事件監聽器
      document.removeEventListener("click", handleDocumentClick);
    };
  });

  // 當 tableID 或 tableKey 變化時重新載入
  $: if (
    (tableID !== lastTableID && tableID >= 0) ||
    (tableKey !== lastTableKey && tableKey >= 0)
  ) {
    lastTableID = tableID;
    lastTableKey = tableKey;
    loadTableData();
  }
  // 載入表格資料
  async function loadTableData() {
    // 檢查 tableID 是否有效
    if (tableID < 0) {
      error = "無效的資料表 ID";
      loading = false;
      return;
    }

    try {
      loading = true;
      error = "";
      const data = await GetTableDataByID(tableID);
      tableData = data as TableData;

      // 計算並分發統計數據
      if (tableData) {
        const stats = calculateStatistics(tableData);
        dispatch("statsUpdate", stats);
      }
    } catch (err) {
      error = `載入資料表失敗: ${err}`;
      tableData = null;
    } finally {
      loading = false;
    }
  }

  // 計算統計數據
  function calculateStatistics(data: TableData) {
    const rowCount = data.rows ? data.rows.length : 0;
    const colCount = data.columns ? data.columns.length : 0;
    const totalCells = rowCount * colCount;

    // 計算數值欄位數量
    let numericCols = 0;
    if (data.columns && data.rows) {
      data.columns.forEach((col) => {
        let hasNumeric = false;
        // 檢查前10行來判斷是否為數值欄位
        for (let i = 0; i < Math.min(10, rowCount); i++) {
          const row = data.rows[i];
          if (row && row.cells) {
            const value = row.cells[col.name];
            if (value && !isNaN(Number(value))) {
              hasNumeric = true;
              break;
            }
          }
        }
        if (hasNumeric) numericCols++;
      });
    }
    return {
      total_rows: rowCount.toString(),
      total_variables: colCount.toString(),
      total_cells: totalCells.toString(),
      numeric_variables: numericCols.toString(),
    };
  } // 儲存格點擊處理
  function handleCellClick(rowIndex: number, colIndex: number, value: string) {
    // 如果正在雙擊過程中，忽略點擊事件
    if (doubleClickInProgress) {
      return;
    }

    // 如果正在編輯其他儲存格（不是當前點擊的格子），先結束編輯
    if (editingState.isEditing) {
      // 檢查是否點擊的是同一個格子
      const isSameCell =
        editingState.rowIndex === rowIndex &&
        editingState.colIndex === colIndex;

      // 如果是同一個格子，只更新選擇狀態，不更新顯示內容和編輯狀態
      if (isSameCell) {
        selectedRow = rowIndex;
        selectedCol = colIndex;
        // 不更新 selectedCellContent，保持編輯中的內容
        return;
      }

      // 只有在點擊不同格子時才結束編輯
      handleEditComplete();
    }

    // 更新選擇狀態為儲存格模式
    selectionMode = "cell";
    selectedRow = rowIndex;
    selectedCol = colIndex;
    selectedRowRange = new Set();
    selectedColRange = new Set();
    // selectedCellContent 會自動由響應式語句更新
  } // 儲存格雙擊處理 (進入編輯模式)
  function handleCellDblClick(
    rowIndex: number,
    colIndex: number,
    colName: string,
    value: string
  ) {
    // 設置雙擊標記
    doubleClickInProgress = true;

    // 如果已經在編輯同一個格子，不要重新進入編輯模式
    if (
      editingState.isEditing &&
      editingState.rowIndex === rowIndex &&
      editingState.colIndex === colIndex
    ) {
      // 清除雙擊標記
      setTimeout(() => {
        doubleClickInProgress = false;
      }, 10);
      return;
    }

    // 如果正在編輯其他格子，先結束編輯
    if (editingState.isEditing) {
      handleEditComplete();
    }

    // 更新選擇狀態，但不更新顯示內容（避免刷新正在輸入的內容）
    selectedRow = rowIndex;
    selectedCol = colIndex;
    // 不更新 selectedCellContent

    // 進入編輯模式
    editingState = {
      tableID,
      rowIndex,
      colIndex,
      colName,
      value,
      isEditing: true,
    };

    // 清除雙擊標記
    setTimeout(() => {
      doubleClickInProgress = false;
    }, 10);
  } // 欄位標題點擊處理
  function handleColumnHeaderClick(colIndex: number, colName: string) {
    // 如果正在雙擊過程中，忽略點擊事件
    if (doubleClickInProgress) {
      return;
    }

    // 如果正在編輯其他欄位標題（不是當前點擊的欄位），先結束編輯
    if (editingState.isEditing) {
      // 檢查是否點擊的是同一個欄位標題
      const isSameHeader =
        editingState.rowIndex === -1 && editingState.colIndex === colIndex;

      // 如果是同一個欄位標題，只更新選擇狀態，不更新顯示內容和編輯狀態
      if (isSameHeader) {
        selectedCol = colIndex;
        selectedRow = -1;
        // 不更新 selectedCellContent，保持編輯中的內容
        return;
      }

      // 只有在點擊不同欄位或不是欄位標題編輯時才結束編輯
      handleEditComplete();
    }

    // 更新選擇狀態和顯示內容
    selectedCol = colIndex;
    selectedRow = -1;
    selectionMode = "column";
    selectedRowRange = new Set();
    selectedColRange = new Set([colIndex]);
    // selectedCellContent 會自動由響應式語句更新
  } // 欄位標題雙擊處理 (進入編輯模式)
  function handleColumnHeaderDblClick(colIndex: number, colName: string) {
    // 設置雙擊標記
    doubleClickInProgress = true;

    // 如果已經在編輯同一個欄位標題，不要重新進入編輯模式
    if (
      editingState.isEditing &&
      editingState.rowIndex === -1 &&
      editingState.colIndex === colIndex
    ) {
      // 清除雙擊標記
      setTimeout(() => {
        doubleClickInProgress = false;
      }, 10);
      return;
    }

    // 如果正在編輯其他元素，先結束編輯
    if (editingState.isEditing) {
      handleEditComplete();
    }

    // 更新選擇狀態，但不更新顯示內容（避免刷新正在輸入的內容）
    selectedCol = colIndex;
    selectedRow = -1;
    // 不更新 selectedCellContent

    // 進入編輯模式
    editingState = {
      tableID,
      rowIndex: -1,
      colIndex,
      colName,
      value: colName,
      isEditing: true,
    };

    // 清除雙擊標記
    setTimeout(() => {
      doubleClickInProgress = false;
    }, 10);
  } // 轉換 nil 值為前端顯示格式
  function formatCellValue(value: any): string {
    // 後端回傳的 nil 值會是 null
    if (value === null || value === undefined) {
      return ".";
    }
    return String(value);
  } // 轉換前端輸入為後端格式
  function parseInputValue(value: string): string {
    // 如果用戶輸入點號，轉換為空字串表示 nil
    if (value === "." || value.trim() === "") {
      return "";
    }
    return value;
  }

  // 編輯完成處理
  async function handleEditComplete() {
    if (!editingState.isEditing) return;

    try {
      if (editingState.rowIndex >= 0) {
        // 更新儲存格值，將用戶輸入的 "." 轉換為空字串
        const processedValue = parseInputValue(editingState.value);
        await UpdateCellValueByID(
          tableID,
          editingState.rowIndex,
          editingState.colIndex,
          processedValue
        );
      } else {
        // 更新欄名
        await UpdateColumnNameByID(
          tableID,
          editingState.colIndex,
          editingState.value
        );
      } // 重新載入資料
      await loadTableData();
    } catch (err) {
      error = `${texts["ui.table.update_failed"] || "更新資料失敗"}: ${err}`;
    } finally {
      // 結束編輯狀態
      editingState = {
        tableID: -1,
        rowIndex: -1,
        colIndex: -1,
        colName: "",
        value: "",
        isEditing: false,
      };
    }
  }

  // 編輯時按下鍵處理
  function handleKeyDown(event: KeyboardEvent) {
    if (event.key === "Enter") {
      event.preventDefault(); // 僅在 Enter 時阻止預設行為
      handleEditComplete();
    } else if (event.key === "Escape") {
      event.preventDefault(); // 僅在 Escape 時阻止預設行為
      // 取消編輯，恢復原值
      editingState = {
        tableID: -1,
        rowIndex: -1,
        colIndex: -1,
        colName: "",
        value: "",
        isEditing: false,
      };
    }
    // 對於其他按鍵，不再呼叫 event.preventDefault()
    // 允許瀏覽器處理正常的文字輸入
  }

  // 將數字索引轉換為字母索引 (A, B, C, ..., AA, AB, ...)
  function indexToLetters(index: number): string {
    if (index < 0) {
      return "A";
    }

    let result = "";
    while (index >= 0) {
      result = String.fromCharCode(65 + (index % 26)) + result;
      index = Math.floor(index / 26) - 1;
      if (index < 0) {
        break;
      }
    }
    return result;
  }
  // 行索引點擊處理 - 選取整行
  function handleRowIndexClick(rowIndex: number) {
    if (editingState.isEditing) {
      handleEditComplete();
    }

    selectionMode = "row";
    selectedRow = rowIndex;
    selectedCol = -1;
    selectedRowRange = new Set([rowIndex]);
    selectedColRange = new Set();
    // selectedCellContent 會自動由響應式語句更新
  }

  // 列索引點擊處理 - 選取整列
  function handleColumnIndexClick(colIndex: number) {
    if (editingState.isEditing) {
      handleEditComplete();
    }

    selectionMode = "column";
    selectedCol = colIndex;
    selectedRow = -1;
    selectedColRange = new Set([colIndex]);
    selectedRowRange = new Set();
    // selectedCellContent 會自動由響應式語句更新
  }
  // 右鍵菜單處理
  function handleContextMenu(
    event: MouseEvent,
    type: string,
    index?: number,
    rowIndex?: number,
    colIndex?: number
  ) {
    event.preventDefault();
    contextMenuVisible = true;
    contextMenuX = event.clientX;
    contextMenuY = event.clientY;
    contextMenuType = type;

    // 設置上下文信息
    contextMenuContext = {
      type,
      index,
      rowIndex,
      colIndex,
      selectedRow,
      selectedCol,
      tableID,
    }; // 根據右鍵類型更新選擇狀態
    if (type === "row" && index !== undefined) {
      handleRowIndexClick(index);
    } else if (type === "column" && index !== undefined) {
      handleColumnIndexClick(index);
    } else if (
      type === "cell" &&
      rowIndex !== undefined &&
      colIndex !== undefined &&
      tableData
    ) {
      const column = tableData.columns[colIndex];
      if (column) {
        const cellValue = tableData.rows[rowIndex]?.cells[column.name];
        const displayValue = formatCellValue(cellValue);
        handleCellClick(rowIndex, colIndex, displayValue);
      }
    }
  }

  // 隱藏右鍵菜單
  function hideContextMenu() {
    contextMenuVisible = false;
  }

  // 點擊文件其他地方時隱藏菜單
  function handleDocumentClick() {
    if (contextMenuVisible) {
      hideContextMenu();
    }
  } // 右鍵菜單項目處理
  async function handleContextMenuAction(event: CustomEvent) {
    const { action, context } = event.detail;

    console.log("Context menu action:", action, "Context:", context);

    switch (action) {
      case "insertRowAbove":
        console.log(`在第 ${context.rowIndex || context.index} 行上方插入行`);
        break;
      case "insertRowBelow":
        console.log(`在第 ${context.rowIndex || context.index} 行下方插入行`);
        break;
      case "duplicateRow":
        console.log(`複製第 ${context.rowIndex || context.index} 行`);
        break;
      case "deleteRow":
        console.log(`刪除第 ${context.rowIndex || context.index} 行`);
        break;
      case "insertColumnLeft":
        console.log(`在第 ${context.colIndex || context.index} 欄左邊插入欄`);
        break;
      case "insertColumnRight":
        console.log(`在第 ${context.colIndex || context.index} 欄右邊插入欄`);
        break;
      case "renameColumn":
        console.log(`重命名第 ${context.colIndex || context.index} 欄`);
        // 可以觸發欄位名稱編輯
        break;
      case "duplicateColumn":
        console.log(`複製第 ${context.colIndex || context.index} 欄`);
        break;
      case "deleteColumn":
        console.log(`刪除第 ${context.colIndex || context.index} 欄`);
        break;
      case "copy":
        console.log(`複製儲存格 (${context.rowIndex}, ${context.colIndex})`);
        // 實現複製功能
        break;
      case "paste":
        console.log(`貼上到儲存格 (${context.rowIndex}, ${context.colIndex})`);
        // 實現貼上功能
        break;
      case "clear":
        console.log(`清除儲存格 (${context.rowIndex}, ${context.colIndex})`);
        // 實現清除功能
        if (context.rowIndex !== undefined && context.colIndex !== undefined) {
          await UpdateCellValueByID(
            tableID,
            context.rowIndex,
            context.colIndex,
            ""
          );
          // 重新載入資料
          await loadTableData();
        }
        break;
      default:
        console.log("未知的菜單動作:", action);
    }
    hideContextMenu();
  }
</script>

<div class="data-table-container">
  {#if loading}
    <div class="loading">{texts["ui.table.loading"] || "載入中..."}</div>
  {:else if error}
    <div class="error">{error}</div>
  {:else if tableData}
    <div class="table-wrapper">
      <table class="data-table">
        <thead>
          <!-- 欄位索引行 (A, B, C, ...) -->
          <tr>
            <!-- 空白頂角儲存格 -->
            <th class="corner-cell corner-index"></th>
            <!-- 欄位索引 -->
            {#each tableData.columns as column, colIndex}
              <th
                class="column-index"
                class:selected={colIndex === selectedCol ||
                  (selectionMode === "column" &&
                    selectedColRange.has(colIndex)) ||
                  (selectionMode === "cell" && colIndex === selectedCol)}
                on:click={() => handleColumnIndexClick(colIndex)}
                on:contextmenu={(e) => handleContextMenu(e, "column", colIndex)}
              >
                {indexToLetters(colIndex)}
              </th>
            {/each}
          </tr>

          <!-- 欄位名稱行 -->
          <tr>
            <!-- 空白頂角儲存格 -->
            <th class="corner-cell corner-header"></th>

            <!-- 欄位標題 -->
            {#each tableData.columns as column, colIndex}
              <th
                class="column-header"
                class:selected={colIndex === selectedCol ||
                  (selectionMode === "column" &&
                    selectedColRange.has(colIndex)) ||
                  (selectionMode === "cell" && colIndex === selectedCol)}
                on:click={() => handleColumnHeaderClick(colIndex, column.name)}
                on:dblclick={() =>
                  handleColumnHeaderDblClick(colIndex, column.name)}
              >
                {#if editingState.isEditing && editingState.rowIndex === -1 && editingState.colIndex === colIndex}
                  <input
                    type="text"
                    bind:value={editingState.value}
                    on:keydown={handleKeyDown}
                    on:blur={handleEditComplete}
                    class="editor"
                    bind:this={editInput}
                  />
                {:else}
                  {column.name}
                {/if}
              </th>
            {/each}
          </tr>
        </thead>
        <tbody>
          {#each tableData.rows as row, rowIndex}
            <tr
              class:selected-row={rowIndex === selectedRow ||
                (selectionMode === "row" && selectedRowRange.has(rowIndex))}
            >
              <!-- 行標識 -->
              <td
                class="row-header"
                class:selected={rowIndex === selectedRow ||
                  (selectionMode === "row" && selectedRowRange.has(rowIndex))}
                on:click={() => handleRowIndexClick(rowIndex)}
                on:contextmenu={(e) => handleContextMenu(e, "row", rowIndex)}
              >
                {rowIndex + 1}
              </td>
              <!-- 儲存格資料 -->
              {#each tableData.columns as column, colIndex}
                {@const cellValue = row.cells[column.name]}
                {@const displayValue = formatCellValue(cellValue)}
                <td
                  class="cell"
                  class:selected-cell={rowIndex === selectedRow &&
                    colIndex === selectedCol}
                  class:selected-col={colIndex === selectedCol ||
                    (selectionMode === "column" &&
                      selectedColRange.has(colIndex)) ||
                    (selectionMode === "cell" && colIndex === selectedCol)}
                  class:selected-row-cell={rowIndex === selectedRow ||
                    (selectionMode === "row" && selectedRowRange.has(rowIndex))}
                  class:nil-value={cellValue === null ||
                    cellValue === undefined}
                  on:click={() =>
                    handleCellClick(rowIndex, colIndex, displayValue)}
                  on:dblclick={() =>
                    handleCellDblClick(
                      rowIndex,
                      colIndex,
                      column.name,
                      displayValue
                    )}
                  on:contextmenu={(e) =>
                    handleContextMenu(e, "cell", undefined, rowIndex, colIndex)}
                  on:keydown={(e) => {
                    if (e.key === "Enter" || e.key === " ") {
                      handleCellClick(rowIndex, colIndex, displayValue);
                    }
                  }}
                  tabindex="0"
                  role="gridcell"
                  >{#if editingState.isEditing && editingState.rowIndex === rowIndex && editingState.colIndex === colIndex}
                    <input
                      type="text"
                      bind:value={editingState.value}
                      on:keydown={handleKeyDown}
                      on:blur={handleEditComplete}
                      class="editor"
                      bind:this={editInput}
                    />
                  {:else}
                    {displayValue}
                  {/if}
                </td>
              {/each}
            </tr>
          {/each}
        </tbody>
      </table>
    </div>
    {#if selectedCellContent}
      <div class="selected-content">
        <strong>{texts["ui.table.selected_content"] || "選中內容"}:</strong>
        {selectedCellContent}
      </div>
    {/if}
  {:else}
    <div class="no-data">{texts["ui.table.no_data"] || "無資料可顯示"}</div>
  {/if}
</div>

<!-- 右鍵菜單組件 -->
<ContextMenu
  visible={contextMenuVisible}
  x={contextMenuX}
  y={contextMenuY}
  type={contextMenuType}
  menuConfig={contextMenuConfig}
  context={contextMenuContext}
  on:action={handleContextMenuAction}
  on:close={hideContextMenu}
/>

<style>
  .data-table-container {
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    font-family:
      "Nunito",
      -apple-system,
      BlinkMacSystemFont,
      "Segoe UI",
      Roboto,
      Oxygen,
      Ubuntu,
      Cantarell,
      "Open Sans",
      "Helvetica Neue",
      sans-serif;
    background: rgba(255, 255, 255, 0.95);
    border-radius: var(--radius-large);
    box-shadow: var(--shadow-2);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .loading,
  .error,
  .no-data {
    padding: var(--spacing-xl);
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    height: 100%;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.9),
      rgba(248, 250, 252, 0.9)
    );
    border-radius: var(--radius-large);
  }

  .loading {
    color: var(--primary-color);
    font-size: 1.1rem;
    font-weight: 500;
  }

  .loading::before {
    content: "";
    width: 40px;
    height: 40px;
    border: 3px solid var(--primary-light);
    border-top: 3px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: var(--spacing-md);
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  .error {
    color: var(--error-color);
    font-weight: 500;
  }

  .no-data {
    color: var(--text-secondary);
    font-style: italic;
  }
  .table-wrapper {
    flex: 1;
    overflow: auto;
    margin: var(--spacing-sm);
    border-radius: var(--radius-medium);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    position: relative;
  }

  .data-table {
    border-collapse: separate;
    border-spacing: 0;
    table-layout: fixed;
    background: transparent;
    min-width: max-content;
  }

  th,
  td {
    padding: var(--spacing-sm) var(--spacing-md);
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 140px;
    min-width: 140px;
    max-width: 140px;
    border: none;
    border-bottom: 1px solid rgba(0, 0, 0, 0.06);
    border-right: 1px solid rgba(0, 0, 0, 0.06);
    position: relative;
    transition: all var(--transition-fast);
  }

  .corner-cell {
    background: linear-gradient(135deg, #f8fafc, #e2e8f0);
    width: 60px;
    min-width: 60px;
    max-width: 60px;
    position: sticky;
    left: 0;
    z-index: 15;
    box-shadow: 2px 0 4px rgba(0, 0, 0, 0.1);
    border-right: 2px solid rgba(0, 0, 0, 0.1) !important;
  }

  .corner-index {
    top: 0;
    border-radius: var(--radius-medium) 0 0 0;
  }

  .corner-header {
    top: 40px;
  }

  .column-index {
    background: linear-gradient(180deg, #f1f5f9, #e2e8f0);
    position: sticky;
    top: 0;
    z-index: 12;
    font-weight: 600;
    text-align: center;
    color: var(--text-secondary);
    font-size: 0.85rem;
    letter-spacing: 0.5px;
    height: 40px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    border-bottom: 2px solid rgba(0, 0, 0, 0.1) !important;
  }

  .column-index.selected {
    background: linear-gradient(
      180deg,
      var(--primary-light),
      var(--primary-color)
    );
    color: var(--text-on-primary);
    box-shadow: 0 4px 8px rgba(25, 118, 210, 0.3);
    transform: translateY(-1px);
  }

  .column-header {
    background: linear-gradient(
      180deg,
      rgba(225, 238, 255, 0.9),
      rgba(191, 219, 254, 0.8)
    );
    position: sticky;
    top: 40px;
    z-index: 11;
    font-weight: 600;
    height: 40px;
    color: var(--text-primary);
    backdrop-filter: blur(10px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    border-bottom: 2px solid rgba(0, 0, 0, 0.1) !important;
  }

  .column-header.selected {
    background: linear-gradient(
      180deg,
      var(--secondary-light),
      var(--secondary-color)
    );
    color: var(--text-primary);
    box-shadow: 0 4px 8px rgba(3, 218, 198, 0.3);
    transform: translateY(-1px);
  }

  .row-header {
    background: linear-gradient(90deg, #f8fafc, #e2e8f0);
    position: sticky;
    left: 0;
    z-index: 9;
    width: 60px;
    min-width: 60px;
    max-width: 60px;
    font-weight: 600;
    text-align: center;
    color: var(--text-secondary);
    font-size: 0.9rem;
    box-shadow: 2px 0 4px rgba(0, 0, 0, 0.1);
    border-right: 2px solid rgba(0, 0, 0, 0.1) !important;
  }

  .row-header.selected {
    background: linear-gradient(
      90deg,
      var(--primary-light),
      var(--primary-color)
    );
    color: var(--text-on-primary);
    box-shadow: 4px 0 8px rgba(25, 118, 210, 0.3);
    transform: translateX(1px);
  }

  .cell {
    position: relative;
    background: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    font-size: 0.9rem;
  }
  .cell:hover:not(.selected-col):not(.selected-row-cell):not(.selected-cell) {
    background: rgba(25, 118, 210, 0.08);
    transform: scale(1.02);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .selected-row {
    background: linear-gradient(
      90deg,
      rgba(25, 118, 210, 0.12),
      rgba(25, 118, 210, 0.06)
    ) !important;
  }

  .selected-col {
    background: linear-gradient(
      180deg,
      rgba(3, 218, 198, 0.25),
      rgba(3, 218, 198, 0.15)
    ) !important;
    position: relative;
    z-index: 2;
  }

  .selected-row-cell {
    background: linear-gradient(
      90deg,
      rgba(25, 118, 210, 0.12),
      rgba(25, 118, 210, 0.06)
    ) !important;
  }

  .selected-cell {
    background: linear-gradient(
      135deg,
      rgba(25, 118, 210, 0.15),
      rgba(3, 218, 198, 0.15)
    ) !important;
    box-shadow: inset 0 0 0 2px var(--primary-color) !important;
    position: relative;
    z-index: 5;
  }
  .selected-row .cell:not(.selected-col) {
    background: linear-gradient(
      90deg,
      rgba(25, 118, 210, 0.08),
      rgba(25, 118, 210, 0.04)
    ) !important;
  }
  .selected-col {
    background: linear-gradient(
      180deg,
      rgba(3, 218, 198, 0.35),
      rgba(3, 218, 198, 0.2)
    ) !important;
    box-shadow: inset 4px 0 0 rgba(3, 218, 198, 0.8) !important;
    position: relative;
    z-index: 3;
  }

  .selected-row .selected-col {
    background: linear-gradient(
      135deg,
      rgba(25, 118, 210, 0.15),
      rgba(3, 218, 198, 0.15)
    ) !important;
    box-shadow:
      0 0 0 2px var(--primary-color),
      0 4px 12px rgba(25, 118, 210, 0.3) !important;
    border-radius: var(--radius-small) !important;
  }

  .nil-value {
    color: var(--text-hint);
    font-style: italic;
    background: linear-gradient(
      135deg,
      rgba(0, 0, 0, 0.02),
      rgba(0, 0, 0, 0.01)
    ) !important;
  }

  .nil-value::before {
    content: "∅";
    opacity: 0.3;
    margin-right: var(--spacing-xs);
  }

  .editor {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: var(--spacing-sm);
    border: 2px solid var(--primary-color);
    border-radius: var(--radius-small);
    box-sizing: border-box;
    outline: none;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    font-family: inherit;
    font-size: inherit;
    color: var(--text-primary);
    box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
    z-index: 10;
  }

  .editor:focus {
    box-shadow:
      0 0 0 3px rgba(25, 118, 210, 0.2),
      0 4px 12px rgba(25, 118, 210, 0.4);
  }

  .selected-content {
    padding: var(--spacing-md);
    background: linear-gradient(
      135deg,
      rgba(248, 250, 252, 0.9),
      rgba(241, 245, 249, 0.8)
    );
    backdrop-filter: blur(10px);
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    font-size: 0.85rem;
    color: var(--text-secondary);
    font-weight: 500;
    border-radius: 0 0 var(--radius-large) var(--radius-large);
  }

  .selected-content strong {
    color: var(--primary-color);
    font-weight: 600;
  }

  /* 滾動條樣式 */
  .table-wrapper::-webkit-scrollbar {
    width: 12px;
    height: 12px;
  }

  .table-wrapper::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.05);
    border-radius: var(--radius-medium);
  }

  .table-wrapper::-webkit-scrollbar-thumb {
    background: linear-gradient(
      135deg,
      var(--primary-color),
      var(--primary-light)
    );
    border-radius: var(--radius-medium);
    border: 2px solid transparent;
    background-clip: content-box;
  }

  .table-wrapper::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(
      135deg,
      var(--primary-dark),
      var(--primary-color)
    );
    background-clip: content-box;
  }

  .table-wrapper::-webkit-scrollbar-corner {
    background: rgba(0, 0, 0, 0.05);
  }

  /* 響應式設計 */
  @media (max-width: 768px) {
    th,
    td {
      width: 120px;
      min-width: 120px;
      max-width: 120px;
      padding: var(--spacing-xs) var(--spacing-sm);
      font-size: 0.8rem;
    }

    .corner-cell,
    .row-header {
      width: 50px;
      min-width: 50px;
      max-width: 50px;
    }

    .column-index,
    .column-header {
      height: 35px;
    }
  }
</style>
